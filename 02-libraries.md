[Оригинал](https://github.com/composer/composer/blob/master/doc/02-libraries.md)
[Оглавление](https://github.com/sergey144010/composer-doc-ru)

# Библиотеки

Этот раздел расскажет Вам о том как сделать Ваши библиотеки устанавливаемыми через Composer.

## Каждый проект является пакетом

Как только у Вас в каталоге появляется `composer.json` файл этот каталог становится пакетом.
Когда Вы добавляете зависимости [`require`](04-schema.md#require) в проект, Вы создаёте
пакет, который зависит от других пакетов. Единственное различие между
Вашим проектом и библиотеками в том, что Ваш проект является пакетом без имени. 

Для того, чтобы сделать пакет установочным Вам нужно дать ему имя. Вы делаете
это путем добавления свойства [`name`](04-schema.md#name) (имя) в `composer.json`:

```json
{
    "name": "acme/hello-world",
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
```

В нашем случае именем проекта является `acme/hello-world`, где `acme` является именем поставщика.
Имя поставщика является обязательным.

> **Примечание:** Если Вы не знаете, что использовать в качестве имени поставщика, Ваше имя пользователя на GitHub обычно является хорошим выбором. Имена пакетов нечувствительны к регистру, все буквы строчные и дефисы для разделения слов.

## Пакеты платформы

Composer содержит пакеты для текущей платформы, которые являются виртуальными пакетами для предметов, которые установлены в системе, но не фактически устанавливаемые через Composer. В это понятие включается сам PHP, PHP расширений и некоторые системные библиотеки.

* `php` представляет версию PHP пользователя, позволяя применить ограничения
  , например `>=5.4.0`. Если требуется 64bit версия php, Вы можете
  потребовать пакет `php-64bit` 
* `hhvm` представляет версию среды выполнения HHVM (aka HipHop Virtual
  Machine) и позволяет применять ограничения, например, '>=2.3.3'. 
* `ext-<name>` позволяет требовать расширения PHP (включая расширения ядра).
  Управление версиями может быть вполне согласованно здесь, так что это часто
  хорошая идея, для того, чтобы просто установить ограничение `*`. Примером расширения
  с именем пакета является `ext-gd`.  
* `lib-<name>` позволяет накладывать ограничения на версии библиотек, используемых
  PHP. Доступны следующие: `curl`, `iconv`, `icu`, `libxml`,
  `openssl`, `pcre`, `uuid`, `xsl`.

Вы можете использовать [`show --platform`](03-cli.md#show) для получения списка локальных пакетов доступных на Вашей платформе.

## Указание версии

Когда Вы публикуете пакет на Packagist, он выводит информацию о версии
из VCS (git, svn, hg, fossil). Это означает, что Вам не придется
явно объявлять версию. Читайте [tags](#tags) (теги) и [branches](#branches) (ветки) чтобы увидеть, как
номера версий извлекаются из них.

Если Вы создаете пакеты вручную и действительно нужно указать версию явно, то
можно просто добавить поле `version` (версии):

```json
{
    "version": "1.0.0"
}
```

> **Примечание:** Вы должны избегать явных указаний полей версий потому,
> что для тегов значение должно совпадать с именем тега.

### Теги

Для каждого тега, который выглядит как версия, пакет с тегом этой версии будет
создан. Он должен соответствовать 'X.Y.Z' или 'vX.Y.Z', с необязательным суффиксом
`-patch` (`-p`), `-alpha` (`-a`), `-beta` (`-b`) или `-RC`. За номером также может следовать суффикс.

Вот несколько примеров допустимых тегов имен:

- 1.0.0
- v1.0.0
- 1.10.5-RC1
- v4.4.4-beta2
- v2.0.0-alpha
- v2.0.4-p1

> **Примечание:** Даже если Ваш тег с префиксом `v`, всё равно
> [ограничение версии](01-basic-usage.md#package-versions) (version constraint) в `require`
> должно быть указано без префикса (например тег `v1.0.0` будет приведён в `1.0.0`).

### Ветви

Для каждой ветви будет создана версия пакета разработки. Если имя ветви выглядит как версия, 
версия будет `{branchname}-dev` (branchname - имя ветви). Например для ветки `2.0` получится версия `2.0.x-dev`
( `.x` добавляется по техническим причинам, чтобы убедиться, что она распознается как ветвь).
Ветка `2.0.x` также будет действительна и превратится соответственно в `2.0.x-dev`.
Если ветка не выглядит как версия, она будет `dev-{branchname}`.
Ветка `master` приводит к версии `dev-master`.

Ниже приведены некоторые примеры имен версий веток:

- 1.x
- 1.0 (приравнивается к 1.0.x)
- 1.1.x

> **Примечание:** При установке версии разработки (development version), 
> это автоматически вытащит её из исходников `source`. Смотрите команду [`install`](03-cli.md#install) (установка)
> для более подробной информации.

### Псевдонимы

Это возможность создания псевдонимов имён веток версий. Например, Вы можете
создать псевдоним для `dev-master` как `1.0.x-dev`, что позволит Вам добавлять
зависимость в пакетах как `1.0.x-dev`.

Смотрите [Псевдонимы](articles/aliases.md) для более подробной информации.

## Файл блокировки

Для Вашей библиотеки Вы можете зафиксировать файл `composer.lock` если хотите.
Это поможет Вашей команде проверить отношения одной и той же версии зависимостей.
Однако этот файл блокировки не будет иметь никакого влияния на другие проекты, которые зависят от него.
Он только влияет на основной проект.

Если Вы не хотите фиксировать файл блокировки и используете git, добавьте его в
`.gitignore`.

## Публикация в VCS

Как только у Вас появится VCS репозиторий (система управления версиями, например git) содержащий
файл `composer.json`, Ваша библиотека уже может быть установлена через Composer. В этом
примере, мы будем публиковать библиотеку `acme/hello-world` на GitHub под
`github.com/username/hello-world`.

Теперь, чтобы проверить установку пакета `acme/hello-world`, мы создаем новый
локальный проект. Будем называть его `acme/blog`. Этот блог будет зависеть от
`acme/hello-world`, который в свою очередь зависит от `monolog/monolog`. Мы можем
добиться этого путем создания где-то нового каталога `blog`,
содержащего `composer.json` со следующим содержимым:

```json
{
    "name": "acme/blog",
    "require": {
        "acme/hello-world": "dev-master"
    }
}
```

Имя в этом случае не требуется, поскольку мы не хотим публиковать блог
как библиотеку. Имя здесь добавляется чтобы уточнить, какой `composer.json`
в настоящее время описывается.

Теперь мы должны сообщить приложению блог где найти зависимость `hello-world`.
Мы делаем это путем добавления репозитория в спецификации пакета блога `composer.json`:

```json
{
    "name": "acme/blog",
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/username/hello-world"
        }
    ],
    "require": {
        "acme/hello-world": "dev-master"
    }
}
```

Для более подробной информации о том, как работают репозитории пакетов и какие другие типы
доступны, см. [Репозитории](05-repositories.md).

Вот и все. Теперь можно установить зависимости, запустив команду Composer
[`install`](03-cli.md#install) !

**Резюме:** Любой репозиторий git/svn/hg/fossil содержащий `composer.json` может быть
добавлен в Ваш проект, указав репозитории пакетов и объявив зависимости в поле [`require`](04-schema.md#require).

## Публикация на packagist

Хорошо, теперь Вы можете публиковать пакеты. Но указывать VCS репозитории
каждый раз слишком громоздко. Вы же не хотите заставлять всех пользователей делать это.

Вы наверное заметили, что мы не указывали репозиторий пакетов для `monolog/monolog`.
Как это работает? Ответ - Packagist.

[Packagist](https://packagist.org/) является основным репозиторием пакетов для
Composer и он включен по умолчанию. Всё, что публикуется на
Packagist автоматически доступно через Composer. Начиная с
[Monolog находится на Packagist](https://packagist.org/packages/monolog/monolog), мы
можем положиться на него без указания каких-либо дополнительных репозиториев.

Если мы захотим поделиться с миром пакетом `hello-world`, мы опубликуем его на packagist.
Сделать это очень легко.

Просто посетите [Packagist](https://packagist.org) и нажмите
кнопку "Submit" (Отправить). Это поможет Вам зарегистрироваться, если Вы еще не сделали этого, а затем
позволит добавить URL в ваш VCS репозиторий, с этого момента Packagist
начнёт сканирование его. Как только это будет сделано, Ваш пакет будет доступен для всех!

&larr; [Базовое использование](01-basic-usage.md) |  [Интерфейс командной строки](03-cli.md) &rarr;
